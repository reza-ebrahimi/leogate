/* automatically generated by rust-bindgen 0.56.0 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct max_align_t {
  pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
  pub __bindgen_padding_0: u64,
  pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
  assert_eq!(
    ::std::mem::size_of::<max_align_t>(),
    32usize,
    concat!("Size of: ", stringify!(max_align_t))
  );
  assert_eq!(
    ::std::mem::align_of::<max_align_t>(),
    16usize,
    concat!("Alignment of ", stringify!(max_align_t))
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
    },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(max_align_t),
      "::",
      stringify!(__clang_max_align_nonce1)
    )
  );
  assert_eq!(
    unsafe {
      &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
    },
    16usize,
    concat!(
      "Offset of field: ",
      stringify!(max_align_t),
      "::",
      stringify!(__clang_max_align_nonce2)
    )
  );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _binary_payload {
  pub payload: *const ::std::os::raw::c_uchar,
  pub size: usize,
}
#[test]
fn bindgen_test_layout__binary_payload() {
  assert_eq!(
    ::std::mem::size_of::<_binary_payload>(),
    16usize,
    concat!("Size of: ", stringify!(_binary_payload))
  );
  assert_eq!(
    ::std::mem::align_of::<_binary_payload>(),
    8usize,
    concat!("Alignment of ", stringify!(_binary_payload))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_binary_payload>())).payload as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_binary_payload),
      "::",
      stringify!(payload)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_binary_payload>())).size as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_binary_payload),
      "::",
      stringify!(size)
    )
  );
}
pub type binary_payload = _binary_payload;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _json_payload {
  pub payload: *const ::std::os::raw::c_char,
  pub size: usize,
}
#[test]
fn bindgen_test_layout__json_payload() {
  assert_eq!(
    ::std::mem::size_of::<_json_payload>(),
    16usize,
    concat!("Size of: ", stringify!(_json_payload))
  );
  assert_eq!(
    ::std::mem::align_of::<_json_payload>(),
    8usize,
    concat!("Alignment of ", stringify!(_json_payload))
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_json_payload>())).payload as *const _ as usize },
    0usize,
    concat!(
      "Offset of field: ",
      stringify!(_json_payload),
      "::",
      stringify!(payload)
    )
  );
  assert_eq!(
    unsafe { &(*(::std::ptr::null::<_json_payload>())).size as *const _ as usize },
    8usize,
    concat!(
      "Offset of field: ",
      stringify!(_json_payload),
      "::",
      stringify!(size)
    )
  );
}
pub type json_payload = _json_payload;
pub type callback = ::std::option::Option<
  unsafe extern "C" fn(
    topic: *const ::std::os::raw::c_char,
    payload: *const json_payload,
    bin_payload: *const binary_payload,
  ),
>;
extern "C" {
  #[doc = " Initializes the global context which is accessible via the function"]
  #[doc = " rclcpp::contexts::get_global_default_context()."]
  #[doc = " Also, installs the global signal handlers with the function"]
  #[doc = " rclcpp::install_signal_handlers()."]
  #[doc = ""]
  #[doc = " \\sa rclcpp::Context::init() for more details on arguments and possible exceptions"]
  pub fn ros2_init();
}
extern "C" {
  #[doc = " If nullptr is given for the context, then the global context is used, i.e."]
  #[doc = " the context initialized by rclcpp::init()."]
  #[doc = ""]
  #[doc = " If the global context is used, then the signal handlers are also uninstalled."]
  #[doc = ""]
  #[doc = " This will also cause the \"on_shutdown\" callbacks to be called."]
  #[doc = ""]
  #[doc = " \\return true if shutdown was successful, false if context was already shutdown"]
  pub fn ros2_shutdown();
}
extern "C" {
  #[doc = " This may return false for a context which has been shutdown, or for a"]
  #[doc = " context that was shutdown due to SIGINT being received by the rclcpp signal"]
  #[doc = " handler."]
  #[doc = ""]
  #[doc = " If nullptr is given for the context, then the global context is used, i.e."]
  #[doc = " the context initialized by rclcpp::init()."]
  #[doc = ""]
  #[doc = " \\return true if shutdown has been called, false otherwise"]
  pub fn ros2_ok() -> bool;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct node {
  _unused: [u8; 0],
}
extern "C" {
  #[doc = " Create a new node with the specified name."]
  #[doc = "**"]
  #[doc = "* \\param[in] node_name Name of the node."]
  #[doc = "* \\throws InvalidNamespaceError if the namespace is invalid"]
  #[doc = "*/"]
  pub fn node_create(n: *const ::std::os::raw::c_char) -> *mut node;
}
extern "C" {
  #[doc = " Destroy a live node."]
  pub fn node_destroy(n: *mut node);
}
extern "C" {
  #[doc = " Get the name of the node."]
  #[doc = "** \\return The name of the node. */"]
  pub fn node_get_name(n: *mut node) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Get the namespace of the node."]
  #[doc = "**"]
  #[doc = "* This namespace is the \"node's\" namespace, and therefore is not affected"]
  #[doc = "* by any sub-namespace's that may affect entities created with this instance."]
  #[doc = "* Use get_effective_namespace() to get the full namespace used by entities."]
  #[doc = "*"]
  #[doc = "* \\sa get_sub_namespace()"]
  #[doc = "* \\sa get_effective_namespace()"]
  #[doc = "* \\return The namespace of the node."]
  #[doc = "*/"]
  pub fn node_get_namespace(n: *mut node) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Get the fully-qualified name of the node."]
  #[doc = "**"]
  #[doc = "* The fully-qualified name includes the local namespace and name of the node."]
  #[doc = "* \\return fully-qualified name of the node."]
  #[doc = "*/"]
  pub fn node_get_fully_qualified_name(n: *mut node) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Get the fully-qualified names of all available nodes."]
  #[doc = "**"]
  #[doc = "* The fully-qualified name includes the local namespace and name of the node."]
  #[doc = "* \\return A vector of fully-qualified names of nodes."]
  #[doc = "*/"]
  pub fn node_get_node_names(n: *mut node) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Return a map of existing topic names to list of topic types."]
  #[doc = "**"]
  #[doc = "* \\return a map of existing topic names to list of topic types."]
  #[doc = "* \\throws std::runtime_error anything that rcl_error can throw"]
  #[doc = "*/"]
  pub fn node_get_topic_names_and_types(n: *mut node) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Return a map of existing service names to list of service types."]
  #[doc = "**"]
  #[doc = "* \\return a map of existing service names to list of service types."]
  #[doc = "* \\throws std::runtime_error anything that rcl_error can throw"]
  #[doc = "*/"]
  pub fn node_get_service_names_and_types(n: *mut node) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Return the sub-namespace, if this is a sub-node, otherwise an empty string."]
  #[doc = "**"]
  #[doc = "* The returned sub-namespace is either the accumulated sub-namespaces which"]
  #[doc = "* were given to one-to-many create_sub_node() calls, or an empty string if"]
  #[doc = "* this is an original node instance, i.e. not a sub-node."]
  #[doc = "*"]
  #[doc = "* For example, consider:"]
  #[doc = "*"]
  #[doc = "* ```cpp"]
  #[doc = "* auto node = std::make_shared<rclcpp::Node>(\"my_node\", \"my_ns\");"]
  #[doc = "* node->get_sub_namespace();  // -> \"\""]
  #[doc = "* auto sub_node1 = node->create_sub_node(\"a\");"]
  #[doc = "* sub_node1->get_sub_namespace();  // -> \"a\""]
  #[doc = "* auto sub_node2 = sub_node1->create_sub_node(\"b\");"]
  #[doc = "* sub_node2->get_sub_namespace();  // -> \"a/b\""]
  #[doc = "* auto sub_node3 = node->create_sub_node(\"foo\");"]
  #[doc = "* sub_node3->get_sub_namespace();  // -> \"foo\""]
  #[doc = "* node->get_sub_namespace();  // -> \"\""]
  #[doc = "* ```"]
  #[doc = "*"]
  #[doc = "* get_namespace() will return the original node namespace, and will not"]
  #[doc = "* include the sub-namespace if one exists."]
  #[doc = "* To get that you need to call the get_effective_namespace() method."]
  #[doc = "*"]
  #[doc = "* \\sa get_namespace()"]
  #[doc = "* \\sa get_effective_namespace()"]
  #[doc = "* \\return the sub-namespace string, not including the node's original namespace"]
  #[doc = "*/"]
  pub fn node_get_sub_namespace(n: *mut node) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Return the effective namespace that is used when creating entities."]
  #[doc = "**"]
  #[doc = "* The returned namespace is a concatenation of the node namespace and the"]
  #[doc = "* accumulated sub-namespaces, which is used as the namespace when creating"]
  #[doc = "* entities which have relative names."]
  #[doc = "*"]
  #[doc = "* For example, consider:"]
  #[doc = "*"]
  #[doc = "* ```cpp"]
  #[doc = "* auto node = std::make_shared<rclcpp::Node>(\"my_node\", \"my_ns\");"]
  #[doc = "* node->get_effective_namespace();  // -> \"/my_ns\""]
  #[doc = "* auto sub_node1 = node->create_sub_node(\"a\");"]
  #[doc = "* sub_node1->get_effective_namespace();  // -> \"/my_ns/a\""]
  #[doc = "* auto sub_node2 = sub_node1->create_sub_node(\"b\");"]
  #[doc = "* sub_node2->get_effective_namespace();  // -> \"/my_ns/a/b\""]
  #[doc = "* auto sub_node3 = node->create_sub_node(\"foo\");"]
  #[doc = "* sub_node3->get_effective_namespace();  // -> \"/my_ns/foo\""]
  #[doc = "* node->get_effective_namespace();  // -> \"/my_ns\""]
  #[doc = "* ```"]
  #[doc = "*"]
  #[doc = "* \\sa get_namespace()"]
  #[doc = "* \\sa get_sub_namespace()"]
  #[doc = "* \\return the sub-namespace string, not including the node's original namespace"]
  #[doc = "*/"]
  pub fn node_get_effective_namespace(n: *mut node) -> *const ::std::os::raw::c_char;
}
extern "C" {
  #[doc = " Get the seconds since epoch"]
  #[doc = "**"]
  #[doc = "* \\warning Depending on sizeof(double) there could be significant precision loss."]
  #[doc = "* When an exact time is required use nanoseconds() instead."]
  #[doc = "*"]
  #[doc = "* \\return the seconds since epoch as a floating point number."]
  #[doc = "*/"]
  pub fn node_time_now_get_seconds(n: *mut node) -> f64;
}
extern "C" {
  pub fn node_subscribe(
    n: *mut node,
    topic: *const ::std::os::raw::c_char,
    type_: *const ::std::os::raw::c_char,
    cb: callback,
  );
}
